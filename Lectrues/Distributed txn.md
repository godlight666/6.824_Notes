# Distributed Transaction

## 问题

分布式情况下，可能数据在不同的服务器上，同一个txn可能要操作不同的server上的数据。

有可能在部分server上操作成功了，但是部分server因为网络或者自身的原因故障了，导致问题（违反了atomic原则）。

## 悲观atomic commit协议：Two phase commit（两阶段提交）

目的是解决上面提到的问题，即一个事务要不全部完成了，要不就什么也没做。（all-or-none)

### 整体结构

有一个txn coordinator（TC），负责协调事务涉及的各个服务器（参与者）。需要将请求发送给各个参与者，比如将x+=1，将y-=1。

有多个参与者，他们负责执行，他们保存了事务需要处理的数据。在参与者上，保存了事务id获取的lock，方便之后unlock以及检查访问权限。

### 流程

![1676685520206](image/Distributedtxn/1676685520206.png)

1. TC将事务涉及的各个操作发送给各个参与方，比如get，put等。各个参与方完成后回复请求给TC。
2. 操作完成后，TC给各个参与方发送prepare请求，告知准备commit。
3. 各个参与方收到prepare请求后，**将当前状态或者各种操作以及锁相关信息写入log**，写入完成后给TC回复Yes/No。
4. TC收到各个参与方的回复后，如果不是所有的都是yes，则abort，**否则将当前状态写入log（磁盘）**，然后再给各个参与方发送commit指令。
5. 各个参与方收到commit后，将本地操作commit，并unlock所有锁，然后回复ACK给TC，这个时候各个参与方可以忘记自己上面事务信息。这时commit后所有操作都写入磁盘了，可以释放占用的内存。
6. TC收到所有ack后，将回复发送给Client。

### 考虑Crash

#### 部分参与方fail

1. 某个参与方在第3步之前就fail，即还没有回复prepare的yse，TC就不会进行下一步，就没有server会进行commit，就没有关系。
2. 如果某个参与方在回复prepare的yes后fail了，这时候TC就会进行后面的步骤，其他参与方就会收到commit，就会进行commit和unlock。**所以就需要每个参与方在回复yes之前将当前内存中的状态和保持的lock信息（即提交该事务的所有信息）保存到log（磁盘）中**，这样当该参与者从fail中恢复过来时，仍然能够具备commit的条件。
3. 至于更之后的时间点，都能够利用上一步的log恢复过来，准备commit和unlock。

#### TC fail

1. 如果在给各个参与方发送commit信息之前fail了，没有关系，不需要什么操作，如果参与方来问，就说不知道这个事务的信息，参与方就会把本地关于这个事务的操作abort。
2. **TC需要在发送各个commit信息之前，将事务的信息（结果以及事务id）永久化到log中**，这样当tc在发送几条或者全部commit信息后fail了，也能从磁盘中恢复，知道这个txn已经提交了。然后给所有参与者重新发送commit信息。

### Network Fail

1. TC一直没收到部分参与方对于prepare的回复，它会尝试重新发送，几次之后就可以选择abort这个txn。因为这个时候还没发送任何commit信息，所以可以选择abort。当那个参与方恢复过来来问的时候，TC中可能没有这个事务的信息就，就可以告诉它已经abort了。
2. 如果参与方一直没有收到prepare信息，也可以选择abort这个事务。当TC再询问关于这个事务时，它就直接回复no，TC也会abort这个事务。
3. **当参与方回复了yes，但是一直没收到commit时，这中间的时间则会被block，它会一直持有锁，并且不能自己选择abort，得一直等下去**。（因为回复了yes后，就有其他参与者commit的可能，参与者不能单方面的abort）。大家为减少在这方面等待的时间做了很多努力。

只有TC才有资格决定abort或者commit，因为它才有全局的信息。但是代价是有可能导致某个参与方一直在等，导致阻塞。

缺点：

1. 要发送大量消息，慢
2. 总是要写入磁盘，慢
3. 参与者可能总是阻塞，慢
4. 参与者可能持有着锁然后还一直阻塞，慢

所以只有一个小规模的服务器集群才会这样用。如果是多个银行之间的，就不会采用，因为不能把自己服务器的运行顺利依赖别人的服务器。
